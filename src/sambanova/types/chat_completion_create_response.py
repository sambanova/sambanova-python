# File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import builtins
from typing import TYPE_CHECKING, List, Union, Optional
from typing_extensions import Literal, TypeAlias

from pydantic import Field as FieldInfo

from .._models import BaseModel

__all__ = [
    "ChatCompletionCreateResponse",
    "ChatCompletionResponse",
    "ChatCompletionResponseChoice",
    "ChatCompletionResponseChoiceMessage",
    "ChatCompletionResponseChoiceLogprobs",
    "ChatCompletionResponseChoiceLogprobsContent",
    "ChatCompletionResponseChoiceLogprobsContentTopLogprobs",
    "ChatCompletionResponseUsage",
    "ChatCompletionStreamResponse",
    "ChatCompletionStreamResponseChoice",
    "ChatCompletionStreamResponseChoiceDelta",
    "ChatCompletionStreamResponseChoiceLogprobs",
    "ChatCompletionStreamResponseChoiceLogprobsContent",
    "ChatCompletionStreamResponseChoiceLogprobsContentTopLogprobs",
    "ChatCompletionStreamResponseUsage",
    "ModelOutputError",
    "ModelOutputErrorError",
    "GeneralError",
    "GeneralErrorError",
]


class ChatCompletionResponseChoiceMessage(BaseModel):
    content: Optional[str] = None
    """The contents of the assistant message."""

    role: Literal["assistant", "user", "system", "tool"]
    """The role of the messages author"""

    tool_calls: Optional[object] = None
    """The tool calls generated by the model."""

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionResponseChoiceLogprobsContentTopLogprobs(BaseModel):
    token: str

    logprob: float

    bytes: Optional[List[int]] = None

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionResponseChoiceLogprobsContent(BaseModel):
    token: str

    logprob: float

    top_logprobs: ChatCompletionResponseChoiceLogprobsContentTopLogprobs

    bytes: Optional[List[int]] = None

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionResponseChoiceLogprobs(BaseModel):
    content: ChatCompletionResponseChoiceLogprobsContent

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionResponseChoice(BaseModel):
    finish_reason: Literal["stop", "length", "tool_calls"]
    """The reason the model stopped generating tokens.

    Will be `stop` if the model hit a natural stop point or a provided stop
    sequence, `length` if the maximum number of tokens specified in the request was
    reached, `tool_calls` if the model called a tool.
    """

    index: int
    """The index of the choice in the list of choices"""

    message: ChatCompletionResponseChoiceMessage

    logprobs: Optional[ChatCompletionResponseChoiceLogprobs] = None
    """Completion Log Probs object"""

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionResponseUsage(BaseModel):
    acceptance_rate: Optional[float] = None
    """acceptance rate"""

    completion_tokens: Optional[int] = None
    """number of tokens generated in completion"""

    completion_tokens_after_first_per_sec: Optional[float] = None
    """completion tokens per second after first token generation"""

    completion_tokens_after_first_per_sec_first_ten: Optional[float] = None
    """completion tokens per second after first token generation first ten"""

    completion_tokens_per_sec: Optional[float] = None
    """completion tokens per second"""

    end_time: Optional[float] = None
    """The Unix timestamp (in seconds) of when the generation finished."""

    is_last_response: Optional[Literal[True]] = None
    """whether or not is last response, always true for non streaming response"""

    prompt_tokens: Optional[int] = None
    """number of tokens used in the prompt sent"""

    start_time: Optional[float] = None
    """The Unix timestamp (in seconds) of when the generation started."""

    time_to_first_token: Optional[float] = None
    """also TTF, time (in seconds) taken to generate the first token"""

    total_latency: Optional[int] = None
    """total time (in seconds) taken to generate the full generation"""

    total_tokens: Optional[int] = None
    """prompt tokens + completion tokens"""

    total_tokens_per_sec: Optional[float] = None
    """tokens per second including prompt and completion"""

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionResponse(BaseModel):
    id: str
    """A unique identifier for the chat completion."""

    choices: List[ChatCompletionResponseChoice]

    created: int
    """The Unix timestamp (in seconds) of when the chat completion was created."""

    model: str
    """The model used for the chat completion."""

    object: Literal["chat.completion"]
    """The object type, always `chat.completion`."""

    system_fingerprint: str
    """Backend configuration that the model runs with."""

    usage: ChatCompletionResponseUsage
    """Usage metrics for the completion request"""


class ChatCompletionStreamResponseChoiceDelta(BaseModel):
    content: Optional[str] = None
    """The contents of the assistant message."""

    role: Optional[Literal["assistant", "user", "system", "tool"]] = None
    """The role of the messages author"""

    tool_calls: Optional[object] = None
    """The tool calls generated by the model."""

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionStreamResponseChoiceLogprobsContentTopLogprobs(BaseModel):
    token: str

    logprob: float

    bytes: Optional[List[int]] = None

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionStreamResponseChoiceLogprobsContent(BaseModel):
    token: str

    logprob: float

    top_logprobs: ChatCompletionStreamResponseChoiceLogprobsContentTopLogprobs

    bytes: Optional[List[int]] = None

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionStreamResponseChoiceLogprobs(BaseModel):
    content: ChatCompletionStreamResponseChoiceLogprobsContent

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionStreamResponseChoice(BaseModel):
    delta: ChatCompletionStreamResponseChoiceDelta
    """completion response delta chunk generated by streamed model responses."""

    finish_reason: Literal["stop", "length", "tool_calls"]
    """The reason the model stopped generating tokens.

    Will be `stop` if the model hit a natural stop point or a provided stop
    sequence, `length` if the maximum number of tokens specified in the request was
    reached, `tool_calls` if the model called a tool.
    """

    index: int
    """The index of the choice in the list of choices"""

    logprobs: Optional[ChatCompletionStreamResponseChoiceLogprobs] = None
    """Completion Log Probs object"""

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionStreamResponseUsage(BaseModel):
    acceptance_rate: Optional[float] = None
    """acceptance rate"""

    completion_tokens: Optional[int] = None
    """number of tokens generated in completion"""

    completion_tokens_after_first_per_sec: Optional[float] = None
    """completion tokens per second after first token generation"""

    completion_tokens_after_first_per_sec_first_ten: Optional[float] = None
    """completion tokens per second after first token generation first ten"""

    completion_tokens_per_sec: Optional[float] = None
    """completion tokens per second"""

    end_time: Optional[float] = None
    """The Unix timestamp (in seconds) of when the generation finished."""

    is_last_response: Optional[Literal[True]] = None
    """whether or not is last response, always true for non streaming response"""

    prompt_tokens: Optional[int] = None
    """number of tokens used in the prompt sent"""

    start_time: Optional[float] = None
    """The Unix timestamp (in seconds) of when the generation started."""

    time_to_first_token: Optional[float] = None
    """also TTF, time (in seconds) taken to generate the first token"""

    total_latency: Optional[int] = None
    """total time (in seconds) taken to generate the full generation"""

    total_tokens: Optional[int] = None
    """prompt tokens + completion tokens"""

    total_tokens_per_sec: Optional[float] = None
    """tokens per second including prompt and completion"""

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...


class ChatCompletionStreamResponse(BaseModel):
    id: str
    """A unique identifier for the chat completion."""

    choices: Optional[List[ChatCompletionStreamResponseChoice]] = None
    """A list of chat completion choices."""

    created: int
    """The Unix timestamp (in seconds) of when the chat completion was created."""

    model: str
    """The model used for the chat completion."""

    object: Literal["chat.completion"]
    """The object type, always `chat.completion`."""

    system_fingerprint: str
    """Backend configuration that the model runs with."""

    usage: Optional[ChatCompletionStreamResponseUsage] = None
    """Usage metrics for the completion request"""

    if TYPE_CHECKING:
        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> builtins.object: ...


class ModelOutputErrorError(BaseModel):
    code: Optional[str] = None
    """error code"""

    message: Optional[str] = None
    """error message"""

    api_model_output: Optional[str] = FieldInfo(alias="model_output", default=None)
    """raw output with errors generated by the model"""

    param: Optional[str] = None
    """error params"""

    type: Optional[str] = None
    """error type"""


class ModelOutputError(BaseModel):
    error: Optional[ModelOutputErrorError] = None

    required: Optional[object] = None


class GeneralErrorError(BaseModel):
    code: Optional[str] = None
    """error code"""

    message: Optional[str] = None
    """error message"""

    param: Optional[str] = None
    """error params"""

    type: Optional[str] = None
    """error type"""


class GeneralError(BaseModel):
    error: Optional[GeneralErrorError] = None

    required: Optional[object] = None


ChatCompletionCreateResponse: TypeAlias = Union[
    ChatCompletionResponse, ChatCompletionStreamResponse, ModelOutputError, GeneralError
]
